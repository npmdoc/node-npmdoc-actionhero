<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://www.actionherojs.com">actionhero (v16.0.5)</a>
</h1>
<h4>actionhero.js is a multi-transport API Server with integrated cluster capabilities and delayed tasks</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero">module actionhero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.actionhero">
            function <span class="apidocSignatureSpan"></span>actionhero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.toString">
            function <span class="apidocSignatureSpan">actionhero.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>actionProcessor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>actions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>chatRoom</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>connections</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>documentation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>exceptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>genericServer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>id</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>params</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>pids</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>resque</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>servers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>socket</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>specHelper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>staticFile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>web</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">actionhero.</span>websocket</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.actionProcessor">module actionhero.actionProcessor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.actionProcessor.initialize">
            function <span class="apidocSignatureSpan">actionhero.actionProcessor.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.actionProcessor.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.actions">module actionhero.actions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.actions.initialize">
            function <span class="apidocSignatureSpan">actionhero.actions.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.actions.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.cache">module actionhero.cache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.cache.initialize">
            function <span class="apidocSignatureSpan">actionhero.cache.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.cache.</span>loadPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.cache.</span>startPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.chatRoom">module actionhero.chatRoom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.chatRoom.initialize">
            function <span class="apidocSignatureSpan">actionhero.chatRoom.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.chatRoom.start">
            function <span class="apidocSignatureSpan">actionhero.chatRoom.</span>start
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.chatRoom.</span>loadPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.chatRoom.</span>startPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.config">module actionhero.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.config.initialize">
            function <span class="apidocSignatureSpan">actionhero.config.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.config.start">
            function <span class="apidocSignatureSpan">actionhero.config.</span>start
            <span class="apidocSignatureSpan">(api, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.config.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.connections">module actionhero.connections</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.connections.initialize">
            function <span class="apidocSignatureSpan">actionhero.connections.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.connections.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.documentation">module actionhero.documentation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.documentation.initialize">
            function <span class="apidocSignatureSpan">actionhero.documentation.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.documentation.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.exceptions">module actionhero.exceptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.exceptions.initialize">
            function <span class="apidocSignatureSpan">actionhero.exceptions.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.exceptions.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.genericServer">module actionhero.genericServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.genericServer.initialize">
            function <span class="apidocSignatureSpan">actionhero.genericServer.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.genericServer.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.id">module actionhero.id</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.id.initialize">
            function <span class="apidocSignatureSpan">actionhero.id.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.id.start">
            function <span class="apidocSignatureSpan">actionhero.id.</span>start
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.id.</span>loadPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.id.</span>startPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.params">module actionhero.params</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.params.initialize">
            function <span class="apidocSignatureSpan">actionhero.params.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.params.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.pids">module actionhero.pids</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.pids.initialize">
            function <span class="apidocSignatureSpan">actionhero.pids.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.pids.start">
            function <span class="apidocSignatureSpan">actionhero.pids.</span>start
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.pids.</span>loadPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.pids.</span>startPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.resque">module actionhero.resque</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.resque.initialize">
            function <span class="apidocSignatureSpan">actionhero.resque.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.resque.start">
            function <span class="apidocSignatureSpan">actionhero.resque.</span>start
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.resque.stop">
            function <span class="apidocSignatureSpan">actionhero.resque.</span>stop
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.resque.</span>loadPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.resque.</span>startPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.resque.</span>stopPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.servers">module actionhero.servers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.servers.initialize">
            function <span class="apidocSignatureSpan">actionhero.servers.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.servers.start">
            function <span class="apidocSignatureSpan">actionhero.servers.</span>start
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.servers.stop">
            function <span class="apidocSignatureSpan">actionhero.servers.</span>stop
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.servers.</span>loadPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.servers.</span>startPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.servers.</span>stopPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.socket">module actionhero.socket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.socket.initialize">
            function <span class="apidocSignatureSpan">actionhero.socket.</span>initialize
            <span class="apidocSignatureSpan">(api, options, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.specHelper">module actionhero.specHelper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.specHelper.initialize">
            function <span class="apidocSignatureSpan">actionhero.specHelper.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.specHelper.start">
            function <span class="apidocSignatureSpan">actionhero.specHelper.</span>start
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.specHelper.</span>loadPriority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.specHelper.</span>startPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.staticFile">module actionhero.staticFile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.staticFile.initialize">
            function <span class="apidocSignatureSpan">actionhero.staticFile.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.staticFile.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.utils">module actionhero.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.utils.initialize">
            function <span class="apidocSignatureSpan">actionhero.utils.</span>initialize
            <span class="apidocSignatureSpan">(api, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">actionhero.utils.</span>loadPriority</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.web">module actionhero.web</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.web.initialize">
            function <span class="apidocSignatureSpan">actionhero.web.</span>initialize
            <span class="apidocSignatureSpan">(api, options, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.actionhero.websocket">module actionhero.websocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.actionhero.websocket.initialize">
            function <span class="apidocSignatureSpan">actionhero.websocket.</span>initialize
            <span class="apidocSignatureSpan">(api, options, next)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero" id="apidoc.module.actionhero">module actionhero</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.actionhero" id="apidoc.element.actionhero.actionhero">
        function <span class="apidocSignatureSpan"></span>actionhero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">actionhero = function () {
  this.initializers = {}
  this.api = {
    running: false,
    initialized: false,
    shuttingDown: false
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.toString" id="apidoc.element.actionhero.toString">
        function <span class="apidocSignatureSpan">actionhero.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (error &amp;&amp; typeof error === 'string') {
  error = new Error(error)
}

if (error &amp;&amp; !this.response.error) {
  if (typeof this.response === 'string' || Array.isArray(this.response)) {
    this.response = error.<span class="apidocCodeKeywordSpan">toString</span>()
  } else {
    this.response.error = error
  }
}

this.incrementPendingActions(-1)
this.duration = new Date().getTime() - this.actionStartTime
...</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.actionProcessor" id="apidoc.module.actionhero.actionProcessor">module actionhero.actionProcessor</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.actionProcessor.initialize" id="apidoc.element.actionhero.actionProcessor.initialize">
        function <span class="apidocSignatureSpan">actionhero.actionProcessor.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  const prepareStringMethod = function (method) {
    const cmdParts = method.split('.')
    const cmd = cmdParts.shift()
    if (cmd !== 'api') { throw new Error('cannot operate on a method outside of the api object') }
    return api.utils.stringToHash(cmdParts.join('.'))
  }

  api.ActionProcessor = function (connection, callback) {
    if (!connection) {
      throw new Error('data.connection is required')
    }

    this.connection = connection
    this.action = null
    this.toProcess = true
    this.toRender = true
    this.messageCount = connection.messageCount
    this.params = connection.params
    this.callback = callback
    this.missingParams = []
    this.validatorErrors = []
    this.actionStartTime = null
    this.actionTemplate = null
    this.working = false
    this.response = {}
    this.duration = null
    this.actionStatus = null
  }

  api.ActionProcessor.prototype.incrementTotalActions = function (count) {
    if (!count) { count = 1 }
    this.connection.totalActions = this.connection.totalActions + count
  }

  api.ActionProcessor.prototype.incrementPendingActions = function (count) {
    if (!count) { count = 1 }
    this.connection.pendingActions = this.connection.pendingActions + count
  }

  api.ActionProcessor.prototype.getPendingActionCount = function () {
    return this.connection.pendingActions
  }

  api.ActionProcessor.prototype.completeAction = function (status) {
    let error = null
    this.actionStatus = String(status)

    if (status instanceof Error) {
      error = status
    } else if (status === 'server_shutting_down') {
      error = api.config.errors.serverShuttingDown(this)
    } else if (status === 'too_many_requests') {
      error = api.config.errors.tooManyPendingActions(this)
    } else if (status === 'unknown_action') {
      error = api.config.errors.unknownAction(this)
    } else if (status === 'unsupported_server_type') {
      error = api.config.errors.unsupportedServerType(this)
    } else if (status === 'missing_params') {
      error = api.config.errors.missingParams(this, this.missingParams)
    } else if (status === 'validator_errors') {
      error = api.config.errors.invalidParams(this, this.validatorErrors)
    } else if (status) {
      error = status
    }

    if (error &amp;&amp; typeof error === 'string') {
      error = new Error(error)
    }

    if (error &amp;&amp; !this.response.error) {
      if (typeof this.response === 'string' || Array.isArray(this.response)) {
        this.response = error.toString()
      } else {
        this.response.error = error
      }
    }

    this.incrementPendingActions(-1)
    this.duration = new Date().getTime() - this.actionStartTime

    process.nextTick(() =&gt; {
      if (typeof this.callback === 'function') {
        this.callback(this)
      }
    })

    this.working = false
    this.logAction(error)
  }

  api.ActionProcessor.prototype.logAction = function (error) {
    // logging
    let logLevel = 'info'
    if (this.actionTemplate &amp;&amp; this.actionTemplate.logLevel) {
      logLevel = this.actionTemplate.logLevel
    }

    let filteredParams = {}
    for (let i in this.params) {
      if (api.config.general.filteredParams &amp;&amp; api.config.general.filteredParams.indexOf(i) &gt;= 0) {
        filteredParams[i] = '[FILTERED]'
      } else if (typeof this.params[i] === 'string') {
        filteredParams[i] = this.params[i].substring(0, api.config.logger.maxLogStringLength)
      } else {
        filteredParams[i] = this.params[i]
      }
    }

    const logLine = {
      to: this.connection.remoteIP,
      action: this.action,
      params: JSON.stringify(filteredParams),
      duration: this.duration
    }

    if (error) {
      if (error instanceof Error) {
        logLine.error = String(error)
      } else {
        try {
          logLine.error = JSON.stringify(error)
        } catch (e) {
          logLine.error = String(error)
        }
      }
    }

    api.log(['[ action @ %s ]', this.connection.type], logLevel, logLine)
  }

  api.ActionProcessor.prototype.preProcessAction = function (callback) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.actions" id="apidoc.module.actionhero.actions">module actionhero.actions</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.actions.initialize" id="apidoc.element.actionhero.actions.initialize">
        function <span class="apidocSignatureSpan">actionhero.actions.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.actions = {}
  api.actions.actions = {}
  api.actions.versions = {}

  api.actions.middleware = {}
  api.actions.globalMiddleware = []

  api.actions.addMiddleware = function (data) {
    if (!data.name) { throw new Error('middleware.name is required') }
    if (!data.priority) { data.priority = api.config.general.defaultMiddlewarePriority }
    data.priority = Number(data.priority)
    api.actions.middleware[data.name] = data
    if (data.global === true) {
      api.actions.globalMiddleware.push(data.name)
      api.utils.sortGlobalMiddleware(api.actions.globalMiddleware, api.actions.middleware)
    }
  }

  api.actions.validateAction = function (action) {
    const fail = (msg) =&gt; {
      return next(new Error(msg))
    }

    if (action.inputs === undefined) {
      action.inputs = {}
    }

    if (typeof action.name !== 'string' || action.name.length &lt; 1) {
      fail('an action is missing \'action.name\'')
      return false
    } else if (typeof action.description !== 'string' || action.description.length &lt; 1) {
      fail('Action ' + action.name + ' is missing \'action.description\'')
      return false
    } else if (typeof action.run !== 'function') {
      fail('Action ' + action.name + ' has no run method')
      return false
    } else if (api.connections !== null &amp;&amp; api.connections.allowedVerbs.indexOf(action.name) &gt;= 0) {
      fail(action.name + ' is a reserved verb for connections. choose a new name')
      return false
    } else {
      return true
    }
  }

  api.actions.loadFile = function (fullFilePath, reload) {
    if (reload === null) { reload = false }

    const loadMessage = (action) =&gt; {
      if (reload) {
        api.log(['action reloaded: %s @ v%s, %s', action.name, action.version, fullFilePath], 'debug')
      } else {
        api.log(['action loaded: %s @ v%s, %s', action.name, action.version, fullFilePath], 'debug')
      }
    }

    api.watchFileAndAct(fullFilePath, function () {
      api.actions.loadFile(fullFilePath, true)
      api.params.buildPostVariables()
      api.routes.loadRoutes()
    })

    let action

    try {
      const collection = require(fullFilePath)
      for (let i in collection) {
        action = collection[i]
        if (action.version === null || action.version === undefined) { action.version = 1.0 }
        if (api.actions.actions[action.name] === null || api.actions.actions[action.name] === undefined) {
          api.actions.actions[action.name] = {}
        }
        api.actions.actions[action.name][action.version] = action
        if (api.actions.versions[action.name] === null || api.actions.versions[action.name] === undefined) {
          api.actions.versions[action.name] = []
        }
        api.actions.versions[action.name].push(action.version)
        api.actions.versions[action.name].sort()
        api.actions.validateAction(api.actions.actions[action.name][action.version])
        loadMessage(action)
      }
    } catch (error) {
      try {
        api.exceptionHandlers.loader(fullFilePath, error)
        delete api.actions.actions[action.name][action.version]
      } catch (err2) {
        throw error
      }
    }
  }

  api.config.general.paths.action.forEach(function (p) {
    api.utils.recursiveDirectoryGlob(p).forEach(function (f) {
      api.actions.loadFile(f)
    })
  })

  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.cache" id="apidoc.module.actionhero.cache">module actionhero.cache</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.cache.initialize" id="apidoc.element.actionhero.cache.initialize">
        function <span class="apidocSignatureSpan">actionhero.cache.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.cache = {}
  api.cache.redisPrefix = api.config.general.cachePrefix
  api.cache.lockPrefix = api.config.general.lockPrefix
  api.cache.lockDuration = api.config.general.lockDuration
  api.cache.lockName = api.id
  api.cache.lockRetry = 100

  const redis = api.redis.clients.client

  api.cache.keys = function (callback) {
    redis.keys(api.cache.redisPrefix + '*', callback)
  }

  api.cache.locks = function (callback) {
    redis.keys(api.cache.lockPrefix + '*', callback)
  }

  api.cache.size = function (callback) {
    api.cache.keys((error, keys) =&gt; {
      let length = 0
      if (keys) { length = keys.length }
      callback(error, length)
    })
  }

  api.cache.clear = function (callback) {
    api.cache.keys((error, keys) =&gt; {
      if (error &amp;&amp; typeof callback === 'function') { return callback(error) }
      let jobs = []
      keys.forEach((key) =&gt; {
        jobs.push((done) =&gt; { redis.del(key, done) })
      })

      async.parallel(jobs, (error) =&gt; {
        if (typeof callback === 'function') { return callback(error) }
      })
    })
  }

  api.cache.dumpWrite = function (file, callback) {
    let data = {}
    api.cache.keys((error, keys) =&gt; {
      if (error &amp;&amp; typeof callback === 'function') { return callback(error) }
      let jobs = []
      keys.forEach((key) =&gt; {
        jobs.push((done) =&gt; {
          redis.get(key, (error, content) =&gt; {
            if (error) { return done(error) }
            data[key] = content
            return done()
          })
        })
      })

      async.parallel(jobs, function (error) {
        if (error) {
          if (typeof callback === 'function') { return callback(error) }
        } else {
          fs.writeFileSync(file, JSON.stringify(data))
          if (typeof callback === 'function') { return callback(null, keys.length) }
        }
      })
    })
  }

  api.cache.dumpRead = function (file, callback) {
    api.cache.clear((error) =&gt; {
      if (error) {
        if (typeof callback === 'function') { return callback(error) }
      } else {
        let jobs = []
        let data
        try {
          data = JSON.parse(fs.readFileSync(file))
        } catch (error) { return callback(error) }

        Object.keys(data).forEach((key) =&gt; {
          let content = data[key]
          jobs.push(function (done) { api.cache.saveDumpedElement(key, content, done) })
        })

        async.series(jobs, (error) =&gt; {
          if (typeof callback === 'function') { return callback(error, Object.keys(data).length) }
        })
      }
    })
  }

  api.cache.saveDumpedElement = function (key, content, callback) {
    let parsedContent
    try {
      parsedContent = JSON.parse(content)
    } catch (error) { return callback(error) }

    redis.set(key, content, (error) =&gt; {
      if (error) { return callback(error) } else if (parsedContent.expireTimestamp) {
        const expireTimeSeconds = Math.ceil((parsedContent.expireTimestamp - new Date().getTime()) / 1000)
        redis.expire(key, expireTimeSeconds, () =&gt; {
          return callback(error)
        })
      } else {
        return callback()
      }
    })
  }

  api.cache.load = function (key, options, callback) {
    // optons: options.expireTimeMS, options.retry
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    redis.get(api.cache.redisPrefix + key, function (error, cacheObj) {
      if (error) { api.log(error, 'error') }
      try { cacheObj = JSON.parse(cacheObj) } catch (e) {}
      if (!cacheObj) {
        if (typeof callback === 'function') {
          return callback(new Error(api.i18n.localize('Object not found')), null, null, null, null)
        }
      } else if (cacheObj.expireTimestamp &gt;= new Date().getTime() || cacheObj.expireTimestamp === null) {
        const lastReadAt = cacheObj.readAt
        let expireTimeSeconds
        cacheObj.readAt = new Date().getTime()
        if (cacheObj.expireTimestamp) {
          if (options.expireTimeMS) {
            cacheObj.expireTimestamp = new Date().getTime() + options.expireTimeMS ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.chatRoom" id="apidoc.module.actionhero.chatRoom">module actionhero.chatRoom</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.chatRoom.initialize" id="apidoc.element.actionhero.chatRoom.initialize">
        function <span class="apidocSignatureSpan">actionhero.chatRoom.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.chatRoom = {}
  api.chatRoom.keys = {
    rooms: 'actionhero:chatRoom:rooms',
    members: 'actionhero:chatRoom:members:'
  }
  api.chatRoom.messageChannel = '/actionhero/chat/chat'

  api.chatRoom.middleware = {}
  api.chatRoom.globalMiddleware = []

  api.chatRoom.addMiddleware = function (data) {
    if (!data.name) { throw new Error('middleware.name is required') }
    if (!data.priority) { data.priority = api.config.general.defaultMiddlewarePriority }
    data.priority = Number(data.priority)
    api.chatRoom.middleware[data.name] = data

    api.chatRoom.globalMiddleware.push(data.name)
    api.chatRoom.globalMiddleware.sort((a, b) =&gt; {
      if (api.chatRoom.middleware[a].priority &gt; api.chatRoom.middleware[b].priority) {
        return 1
      } else {
        return -1
      }
    })
  }

  api.chatRoom.broadcast = function (connection, room, message, callback) {
    if (!room || room.length === 0 || message === null || message.length === 0) {
      if (typeof callback === 'function') { process.nextTick(() =&gt; { callback(api.config.errors.connectionRoomAndMessage(connection
)) }) }
    } else if (connection.rooms === undefined || connection.rooms.indexOf(room) &gt; -1) {
      if (connection.id === undefined) { connection.id = 0 }
      const payload = {
        messageType: 'chat',
        serverToken: api.config.general.serverToken,
        serverId: api.id,
        message: message,
        sentAt: new Date().getTime(),
        connection: {
          id: connection.id,
          room: room
        }
      }
      const messagePayload = api.chatRoom.generateMessagePayload(payload)

      api.chatRoom.handleCallbacks(connection, messagePayload.room, 'onSayReceive', messagePayload, (error, newPayload) =&gt; {
        if (error) {
          if (typeof callback === 'function') { process.nextTick(() =&gt; { callback(error) }) }
        } else {
          const payloadToSend = {
            messageType: 'chat',
            serverToken: api.config.general.serverToken,
            serverId: api.id,
            message: newPayload.message,
            sentAt: newPayload.sentAt,
            connection: {
              id: newPayload.from,
              room: newPayload.room
            }
          }
          api.redis.publish(payloadToSend)
          if (typeof callback === 'function') { process.nextTick(() =&gt; { callback(null) }) }
        }
      })
    } else {
      if (typeof callback === 'function') { process.nextTick(() =&gt; { callback(api.config.errors.connectionNotInRoom(connection,
room)) }) }
    }
  }

  api.chatRoom.generateMessagePayload = function (message) {
    return {
      message: message.message,
      room: message.connection.room,
      from: message.connection.id,
      context: 'user',
      sentAt: message.sentAt
    }
  }

  api.chatRoom.incomingMessage = function (message) {
    const messagePayload = api.chatRoom.generateMessagePayload(message)
    for (let i in api.connections.connections) {
      api.chatRoom.incomingMessagePerConnection(api.connections.connections[i], messagePayload)
    }
  }

  api.chatRoom.incomingMessagePerConnection = function (connection, messagePayload) {
    if (connection.canChat === true) {
      if (connection.rooms.indexOf(messagePayload.room) &gt; -1) {
        api.chatRoom.handleCallbacks(connection, messagePayload.room, 'say', messagePayload, (error, newMessagePayload) =&gt; {
          if (!error) { connection.sendMessage(newMessagePayload, 'say') }
        })
      }
    }
  }

  api.chatRoom.list = function (callback) {
    api.redis.clients.client.smembers(api.chatRoom.keys.rooms, (error, rooms) =&gt; {
      if (typeof callback === 'function') { callback(error, rooms) }
    })
  }

  api.chatRoom.add = function (room, callback) {
    api.chatRoom.exists(room, function (error, found) {
      if (error) { return callback(error) }
      if (found === false) {
        api.redis.clients.client.sadd(api.chatRoom.keys.rooms, room, (error, count) =&gt; {
          if (typeof callback === 'function') { callback(error, count) }
        })
      } else { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.chatRoom.start" id="apidoc.element.actionhero.chatRoom.start">
        function <span class="apidocSignatureSpan">actionhero.chatRoom.</span>start
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (api, next) {
  api.redis.subscriptionHandlers.chat = (message) =&gt; {
    if (api.chatRoom) {
      api.chatRoom.incomingMessage(message)
    }
  }

  if (api.config.general.startingChatRooms) {
    for (let room in api.config.general.startingChatRooms) {
      api.log(['ensuring the existence of the chatRoom: %s', room])
      api.chatRoom.add(room)
    }
  }

  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">start</span>(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.config" id="apidoc.module.actionhero.config">module actionhero.config</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.config.initialize" id="apidoc.element.actionhero.config.initialize">
        function <span class="apidocSignatureSpan">actionhero.config.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  // api.env

  if (api._startingParams &amp;&amp; api._startingParams.api) {
    api.utils.hashMerge(api, api._startingParams.api)
  }

  api.env = 'development'

  if (argv.NODE_ENV) {
    api.env = argv.NODE_ENV
  } else if (process.env.NODE_ENV) {
    api.env = process.env.NODE_ENV
  }

  // reloading in development mode

  api.watchedFiles = []

  api.watchFileAndAct = function (file, callback) {
    file = path.normalize(file)

    if (!fs.existsSync(file)) {
      throw new Error(file + ' does not exist, and cannot be watched')
    }

    if (api.config.general.developmentMode === true &amp;&amp; api.watchedFiles.indexOf(file) &lt; 0) {
      api.watchedFiles.push(file)
      fs.watchFile(file, {interval: 1000}, (curr, prev) =&gt; {
        if (
          api.running === true &amp;&amp;
          api.config.general.developmentMode === true &amp;&amp;
          curr.mtime &gt; prev.mtime
        ) {
          process.nextTick(() =&gt; {
            let cleanPath = file
            if (process.platform === 'win32') { cleanPath = file.replace(/\//g, '\\') }
            delete require.cache[require.resolve(cleanPath)]
            callback(file)
          })
        }
      })
    }
  }

  api.unWatchAllFiles = function () {
    for (let i in api.watchedFiles) {
      fs.unwatchFile(api.watchedFiles[i])
    }
    api.watchedFiles = []
  }

  // We support multiple configuration paths as follows:
  //
  // 1. Use the project 'config' folder, if it exists.
  // 2. "actionhero --config=PATH1 --config=PATH2 --config=PATH3,PATH4"
  // 3. "ACTIONHERO_CONFIG=PATH1,PATH2 npm start"
  //
  // Note that if --config or ACTIONHERO_CONFIG are used, they _overwrite_ the use of the default "config" folder. If
  // you wish to use both, you need to re-specify "config", e.g. "--config=config,local-config". Also, note that
  // specifying multiple --config options on the command line does exactly the same thing as using one parameter with
  // comma separators, however the environment variable method only supports the comma-delimited syntax.
  let configPaths = []

  function addConfigPath (pathToCheck, alreadySplit) {
    if (typeof pathToCheck === 'string') {
      if (!alreadySplit) {
        addConfigPath(pathToCheck.split(','), true)
      } else {
        if (pathToCheck.charAt(0) !== '/') {
          pathToCheck = path.resolve(api.projectRoot, pathToCheck)
        }
        if (fs.existsSync(pathToCheck)) {
          configPaths.push(pathToCheck)
        }
      }
    } else if (Array.isArray(pathToCheck)) {
      pathToCheck.map((entry) =&gt; { addConfigPath(entry, alreadySplit) })
    }
  }

  [argv.config, process.env.ACTIONHERO_CONFIG].map((entry) =&gt; { addConfigPath(entry, false) })

  if (configPaths.length &lt; 1) {
    addConfigPath('config', false)
  }

  if (configPaths.length &lt; 1) {
    return next(new Error(configPaths + 'No config directory found in this project, specified with --config, or found in process
.env.ACTIONHERO_CONFIG'))
  }

  const rebootCallback = (file) =&gt; {
    api.log(['*** rebooting due to config change (%s) ***', file], 'info')
    delete require.cache[require.resolve(file)]
    api.commands.restart()
  }

  api.loadConfigDirectory = function (configPath, watch) {
    const configFiles = api.utils.recursiveDirectoryGlob(configPath)

    let loadRetries = 0
    let loadErrors = {}
    for (let i = 0, limit = configFiles.length; (i &lt; limit); i++) {
      const f = configFiles[i]
      try {
        // attempt configuration file load
        let localConfig = require(f)
        if (localConfig['default']) { api.config = api.utils.hashMerge(api.config, localConfig['default'], api) }
        if (localConfig[api.env]) { api.config = api.utils.hashMerge(api.config, localConfig[api.env], api) }
        // configuration file load success: clear retries and
        // errors since progress has been made
        loadRetries = 0
        loadErrors = {}
      } catch (error) {
        // error loading configuration, abort if all remaining
        // configuration files have been tried and failed
        // indicating inability to progres ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.config.start" id="apidoc.element.actionhero.config.start">
        function <span class="apidocSignatureSpan">actionhero.config.</span>start
        <span class="apidocSignatureSpan">(api, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (api, callback) {
  api.log(['environment: %s', api.env], 'notice')
  callback()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">start</span>(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.connections" id="apidoc.module.actionhero.connections">module actionhero.connections</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.connections.initialize" id="apidoc.element.actionhero.connections.initialize">
        function <span class="apidocSignatureSpan">actionhero.connections.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.connections = {

    middleware: {},
    globalMiddleware: [],

    allowedVerbs: [
      'quit',
      'exit',
      'documentation',
      'paramAdd',
      'paramDelete',
      'paramView',
      'paramsView',
      'paramsDelete',
      'roomAdd',
      'roomLeave',
      'roomView',
      'detailsView',
      'say'
    ],

    connections: {},

    apply: function (connectionId, method, args, callback) {
      if (args === undefined &amp;&amp; callback === undefined &amp;&amp; typeof method === 'function') {
        callback = method; args = null; method = null
      }
      api.redis.doCluster('api.connections.applyCatch', [connectionId, method, args], connectionId, callback)
    },

    applyCatch: function (connectionId, method, args, callback) {
      const connection = api.connections.connections[connectionId]
      if (method &amp;&amp; args) {
        if (method === 'sendMessage' || method === 'sendFile') {
          connection[method](args)
        } else {
          connection[method].apply(connection, args)
        }
      }
      if (typeof callback === 'function') {
        process.nextTick(() =&gt; {
          callback(cleanConnection(connection))
        })
      }
    },

    addMiddleware: function (data) {
      if (!data.name) { throw new Error('middleware.name is required') }
      if (!data.priority) { data.priority = api.config.general.defaultMiddlewarePriority }
      data.priority = Number(data.priority)
      api.connections.middleware[data.name] = data

      this.globalMiddleware.push(data.name)
      this.globalMiddleware.sort((a, b) =&gt; {
        if (api.connections.middleware[a].priority &gt; api.connections.middleware[b].priority) {
          return 1
        } else {
          return -1
        }
      })
    }
  }

  const cleanConnection = function (connection) {
    let clean = {}
    for (let i in connection) {
      if (i !== 'rawConnection') {
        clean[i] = connection[i]
      }
    }
    return clean
  }

  // {type: type, remotePort: remotePort, remoteIP: remoteIP, rawConnection: rawConnection}
  // id is optional and will be generated if missing
  api.Connection = function (data) {
    this.setup(data)
    api.connections.connections[this.id] = this

    api.connections.globalMiddleware.forEach((middlewareName) =&gt; {
      if (typeof api.connections.middleware[middlewareName].create === 'function') {
        api.connections.middleware[middlewareName].create(this)
      }
    })
  }

  api.Connection.prototype.setup = function (data) {
    if (data.id) {
      this.id = data.id
    } else {
      this.id = this.generateID()
    }
    this.connectedAt = new Date().getTime();

    ['type', 'rawConnection'].forEach((req) =&gt; {
      if (data[req] === null || data[req] === undefined) { throw new Error(req + ' is required to create a new connection object
') }
      this[req] = data[req]
    });

    ['remotePort', 'remoteIP'].forEach((req) =&gt; {
      if (data[req] === null || data[req] === undefined) {
        if (api.config.general.enforceConnectionProperties === true) {
          throw new Error(req + ' is required to create a new connection object')
        } else {
          data[req] = 0 // could be a random uuid as well?
        }
      }
      this[req] = data[req]
    })

    const connectionDefaults = {
      error: null,
      fingerprint: this.id,
      rooms: [],
      params: {},
      pendingActions: 0,
      totalActions: 0,
      messageCount: 0,
      canChat: false
    }

    for (let i in connectionDefaults) {
      if (this[i] === undefined &amp;&amp; data[i] !== undefined) { this[i] = data[i] }
      if (this[i] === undefined) { this[i] = connectionDefaults[i] }
    }

    api.i18n.invokeConnectionLocale(this)
  }

  api.Connection.prototype.localize = function (message) {
    // this.locale will be sourced automatically
    return api.i18n.localize(message, this)
  }

  api.Connection.prototype.generateID = function () {
    return uuid.v4()
  }

  api.Connection.prototype.destroy = function (callback) {
    this.destroyed = true

    api.connections.globalMiddleware ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.documentation" id="apidoc.module.actionhero.documentation">module actionhero.documentation</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.documentation.initialize" id="apidoc.element.actionhero.documentation.initialize">
        function <span class="apidocSignatureSpan">actionhero.documentation.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.documentation = {
    documentation: {},
    build: () =&gt; {
      let action
      for (let i in api.actions.actions) {
        for (let j in api.actions.actions[i]) {
          action = api.actions.actions[i][j]
          if (action.toDocument !== false) {
            if (!api.documentation.documentation[action.name]) { api.documentation.documentation[action.name] = {} }
            api.documentation.documentation[action.name][action.version] = {
              name: action.name,
              version: action.version,
              description: action.description,
              inputs: action.inputs,
              outputExample: action.outputExample
            }
          }
        }
      }
    }
  }

  api.documentation.build()
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.exceptions" id="apidoc.module.actionhero.exceptions">module actionhero.exceptions</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.exceptions.initialize" id="apidoc.element.actionhero.exceptions.initialize">
        function <span class="apidocSignatureSpan">actionhero.exceptions.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.exceptionHandlers = {}
  api.exceptionHandlers.reporters = []

  const consoleReporter = function (error, type, name, objects, severity) {
    let extraMessages = []

    if (type === 'loader') {
      extraMessages.push('! Failed to load ' + objects.fullFilePath)
    } else if (type === 'action') {
      extraMessages.push('! uncaught error from action: ' + name)
      extraMessages.push('! connection details:')
      const relevantDetails = ['action', 'remoteIP', 'type', 'params', 'room']
      for (let i in relevantDetails) {
        if (
          objects.connection[relevantDetails[i]] !== null &amp;&amp;
          objects.connection[relevantDetails[i]] !== undefined &amp;&amp;
          typeof objects.connection[relevantDetails[i]] !== 'function'
        ) {
          extraMessages.push('!     ' + relevantDetails[i] + ': ' + JSON.stringify(objects.connection[relevantDetails[i]]))
        }
      }
    } else if (type === 'task') {
      extraMessages.push('! error from task: ' + name + ' on queue ' + objects.queue + ' (worker #' + objects.workerId + ')')
      try {
        extraMessages.push('!     arguments: ' + JSON.stringify(objects.task.args))
      } catch (e) {}
    } else {
      extraMessages.push('! Error: ' + error.message)
      extraMessages.push('!     Type: ' + type)
      extraMessages.push('!     Name: ' + name)
      extraMessages.push('!     Data: ' + JSON.stringify(objects))
    }

    for (let m in extraMessages) {
      api.log(extraMessages[m], severity)
    }
    let lines
    try {
      lines = error.stack.split(os.EOL)
    } catch (e) {
      lines = new Error(error).stack.split(os.EOL)
    }
    for (let l in lines) {
      let line = lines[l]
      api.log('! ' + line, severity)
    }
    api.log('*', severity)
  }

  api.exceptionHandlers.reporters.push(consoleReporter)

  api.exceptionHandlers.report = function (error, type, name, objects, severity) {
    if (!severity) { severity = 'error' }
    for (let i in api.exceptionHandlers.reporters) {
      api.exceptionHandlers.reporters[i](error, type, name, objects, severity)
    }
  }

  // /////////
  // TYPES //
  // /////////

  api.exceptionHandlers.loader = function (fullFilePath, error) {
    let name = 'loader:' + fullFilePath
    api.exceptionHandlers.report(error, 'loader', name, {fullFilePath: fullFilePath}, 'alert')
  }

  api.exceptionHandlers.action = function (error, data, next) {
    let simpleName
    try {
      simpleName = data.action
    } catch (e) {
      simpleName = error.message
    }
    let name = 'action:' + simpleName
    api.exceptionHandlers.report(error, 'action', name, {connection: data.connection}, 'error')
    data.connection.response = {} // no partial responses
    if (typeof next === 'function') { next() }
  }

  api.exceptionHandlers.task = function (error, queue, task, workerId) {
    let simpleName
    try {
      simpleName = task['class']
    } catch (e) {
      simpleName = error.message
    }
    let name = 'task:' + simpleName
    api.exceptionHandlers.report(error, 'task', name, {task: task, queue: queue, workerId: workerId}, api.config.tasks.workerLogging
.failure)
  }

  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.genericServer" id="apidoc.module.actionhero.genericServer">module actionhero.genericServer</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.genericServer.initialize" id="apidoc.element.actionhero.genericServer.initialize">
        function <span class="apidocSignatureSpan">actionhero.genericServer.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  // I am the prototypical generic server that all other types of servers inherit from.
  // I shouldn't actually be used by a client
  // Note the methods in this template server, as they are all required for 'real' servers

  // //////////////////
  // COMMON METHODS //
  // //////////////////

  // options are meant to be configurable in 'config.js'
  // attributes are descriptions of the server:
<span class="apidocCodeCommentSpan">  /*

    attributes = {
      canChat: true,
      logConnections: true,
      logExits: true,
      sendWelcomeMessage: true,
      verbs: ['say', 'detailsView']
    }

  */
</span>
  api.GenericServer = function (name, options, attributes) {
    this.type = name
    this.options = options
    this.attributes = attributes

    // you can overwrite attributes with options
    // this could cause some problems, be careful
    for (let key in this.options) {
      if (this.attributes[key] !== null &amp;&amp; this.attributes[key] !== undefined) {
        this.attributes[key] = this.options[key]
      }
    }
  }

  util.inherits(api.GenericServer, EventEmitter)

  api.GenericServer.prototype.buildConnection = function (data) {
    const details = {
      type: this.type,
      id: data.id,
      remotePort: data.remotePort,
      remoteIP: data.remoteAddress,
      rawConnection: data.rawConnection
    }
    if (this.attributes.canChat === true) { details.canChat = true }
    if (data.fingerprint) { details.fingerprint = data.fingerprint }
    let connection = new api.Connection(details)

    connection.sendMessage = (message) =&gt; {
      this.sendMessage(connection, message)
    }

    connection.sendFile = (path) =&gt; {
      connection.params.file = path
      this.processFile(connection)
    }

    this.emit('connection', connection)

    if (this.attributes.logConnections === true) {
      this.log('new connection', 'info', {to: connection.remoteIP})
    }

    if (this.attributes.sendWelcomeMessage === true) {
      connection.sendMessage({welcome: api.config.general.welcomeMessage, context: 'api'})
    }

    if (typeof this.attributes.sendWelcomeMessage === 'number') {
      setTimeout(() =&gt; {
        try {
          connection.sendMessage({welcome: api.config.general.welcomeMessage, context: 'api'})
        } catch (e) {
          api.log(e, 'error')
        }
      }, this.attributes.sendWelcomeMessage)
    }
  }

  api.GenericServer.prototype.processAction = function (connection) {
    const ActionProcessor = new api.ActionProcessor(connection, (data) =&gt; {
      this.emit('actionComplete', data)
    })

    ActionProcessor.processAction()
  }

  api.GenericServer.prototype.processFile = function (connection) {
    api.staticFile.get(connection, (connection, error, fileStream, mime, length, lastModified) =&gt; {
      this.sendFile(connection, error, fileStream, mime, length, lastModified)
    })
  }

  api.GenericServer.prototype.connections = function () {
    let connections = []

    for (let i in api.connections.connections) {
      let connection = api.connections.connections[i]
      if (connection.type === this.type) { connections.push(connection) }
    }

    return connections
  }

  api.GenericServer.prototype.log = function (message, severity, data) {
    api.log(['[server: %s] %s', this.type, message], severity, data)
  }

  const methodNotDefined = function () {
    throw new Error('The containing method should be defined for this server type')
  }

  // /////////////////////////////////////
  // METHODS WHICH MUST BE OVERWRITTEN //
  // /////////////////////////////////////

  // I am invoked as part of boot
  api.GenericServer.prototype.start = function (next) { methodNotDefined() }

  // I am invoked as part of shutdown
  api.GenericServer.prototype.stop = function (next) { methodNotDefined() }

  // This method will be appended to the connection as 'connection.sendMessage'
  api.GenericServer.prototype.sendMessage = function (connection, message) { methodNotDefined() }

  // This method will be used to gracefully disconnect the client
  api.GenericServer.prototype.goodbye = function (connection, re ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.id" id="apidoc.module.actionhero.id">module actionhero.id</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.id.initialize" id="apidoc.element.actionhero.id.initialize">
        function <span class="apidocSignatureSpan">actionhero.id.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  if (argv.title) {
    api.id = argv.title
  } else if (process.env.ACTIONHERO_TITLE) {
    api.id = process.env.ACTIONHERO_TITLE
  } else if (!api.config.general.id) {
    let externalIP = api.utils.getExternalIPAddress()
    if (externalIP === false) {
      let message = ' * Error fetching this hosts external IP address; setting id base to \'actionhero\''
      try {
        api.log(message, 'crit')
      } catch (e) {
        console.log(message)
      }
      externalIP = 'actionhero'
    }

    api.id = externalIP
    if (cluster.isWorker) { api.id += ':' + process.pid }
  } else {
    api.id = api.config.general.id
  }

  api.actionheroVersion = require('..' + path.sep + 'package.json').version

  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.id.start" id="apidoc.element.actionhero.id.start">
        function <span class="apidocSignatureSpan">actionhero.id.</span>start
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (api, next) {
  api.log(['server ID: %s', api.id], 'notice')
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">start</span>(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.params" id="apidoc.module.actionhero.params">module actionhero.params</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.params.initialize" id="apidoc.element.actionhero.params.initialize">
        function <span class="apidocSignatureSpan">actionhero.params.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.params = {}

  // special params we will always accept
  api.params.globalSafeParams = [
    'file',
    'apiVersion',
    'callback',
    'action'
  ]

  api.params.buildPostVariables = function () {
    let postVariables = []
    let i
    let j

    api.params.globalSafeParams.forEach(function (p) {
      postVariables.push(p)
    })

    for (i in api.actions.actions) {
      for (j in api.actions.actions[i]) {
        let action = api.actions.actions[i][j]
        for (let key in action.inputs) {
          postVariables.push(key)
        }
      }
    }

    api.params.postVariables = api.utils.arrayUniqueify(postVariables)
    return api.params.postVariables
  }

  api.params.buildPostVariables()
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.pids" id="apidoc.module.actionhero.pids">module actionhero.pids</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.pids.initialize" id="apidoc.element.actionhero.pids.initialize">
        function <span class="apidocSignatureSpan">actionhero.pids.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.pids = {}
  api.pids.pid = process.pid
  api.pids.path = api.config.general.paths.pid[0] // it would be silly to have more than one pid

  api.pids.sanitizeId = function () {
    let pidfile = api.id
    pidfile = pidfile.replace(new RegExp(':', 'g'), '-')
    pidfile = pidfile.replace(new RegExp(' ', 'g'), '_')
    pidfile = pidfile.replace(new RegExp('\r', 'g'), '') // eslint-disable-line
    pidfile = pidfile.replace(new RegExp('\n', 'g'), '') // eslint-disable-line

    return pidfile
  }

  if (cluster.isMaster) {
    api.pids.title = 'actionhero-' + api.pids.sanitizeId()
  } else {
    api.pids.title = api.pids.sanitizeId()
  }

  try { fs.mkdirSync(api.pids.path) } catch (e) {};

  api.pids.writePidFile = function () {
    fs.writeFileSync(api.pids.path + '/' + api.pids.title, api.pids.pid.toString(), 'ascii')
  }

  api.pids.clearPidFile = function () {
    try {
      fs.unlinkSync(api.pids.path + '/' + api.pids.title)
    } catch (e) {
      api.log('Unable to remove pidfile', 'error', e)
    }
  }

  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.pids.start" id="apidoc.element.actionhero.pids.start">
        function <span class="apidocSignatureSpan">actionhero.pids.</span>start
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (api, next) {
  api.pids.writePidFile()
  api.log(['pid: %s', process.pid], 'notice')
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">start</span>(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.resque" id="apidoc.module.actionhero.resque">module actionhero.resque</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.resque.initialize" id="apidoc.element.actionhero.resque.initialize">
        function <span class="apidocSignatureSpan">actionhero.resque.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  const resqueOverrides = api.config.tasks.resque_overrides

  api.resque = {
    verbose: false,
    queue: null,
    multiWorker: null,
    scheduler: null,
    connectionDetails: {redis: api.redis.clients.tasks},

    startQueue: function (callback) {
      let Queue = NR.queue
      if (resqueOverrides &amp;&amp; resqueOverrides.queue) { Queue = resqueOverrides.queue }
      this.queue = new Queue({connection: this.connectionDetails}, api.tasks.jobs)

      this.queue.on('error', (error) =&gt; {
        api.log(error, 'error', '[api.resque.queue]')
      })

      this.queue.connect(callback)
    },

    stopQueue: function (callback) {
      if (api.resque.queue) { api.resque.queue.end(callback) } else { callback() }
    },

    startScheduler: function (callback) {
      let Scheduler = NR.scheduler
      if (resqueOverrides &amp;&amp; resqueOverrides.scheduler) { Scheduler = resqueOverrides.scheduler }
      if (api.config.tasks.scheduler === true) {
        this.schedulerLogging = api.config.tasks.schedulerLogging
        this.scheduler = new Scheduler({connection: this.connectionDetails, timeout: api.config.tasks.timeout})

        this.scheduler.on('error', (error) =&gt; {
          api.log(error, 'error', '[api.resque.scheduler]')
        })

        this.scheduler.connect(() =&gt; {
          this.scheduler.on('start', () =&gt; { api.log('resque scheduler started', this.schedulerLogging.start) })
          this.scheduler.on('end', () =&gt; { api.log('resque scheduler ended', this.schedulerLogging.end) })
          this.scheduler.on('poll', () =&gt; { api.log('resque scheduler polling', this.schedulerLogging.poll) })
          this.scheduler.on('working_timestamp', (timestamp) =&gt; { api.log(['resque scheduler working timestamp %s', timestamp],
this.schedulerLogging.working_timestamp) })
          this.scheduler.on('transferred_job', (timestamp, job) =&gt; { api.log(['resque scheduler enqueuing job %s', timestamp], this
.schedulerLogging.transferred_job, job) })
          this.scheduler.on('master', (state) =&gt; { api.log(['This node is now the Resque scheduler master']) })

          this.scheduler.start()
          callback()
        })
      } else {
        callback()
      }
    },

    stopScheduler: function (callback) {
      if (!this.scheduler) {
        callback()
      } else {
        this.scheduler.end(() =&gt; {
          delete this.scheduler
          callback()
        })
      }
    },

    startMultiWorker: function (callback) {
      let MultiWorker = NR.multiWorker
      if (resqueOverrides &amp;&amp; resqueOverrides.multiWorker) { MultiWorker = resqueOverrides.multiWorker }
      this.workerLogging = api.config.tasks.workerLogging
      this.schedulerLogging = api.config.tasks.schedulerLogging

      this.multiWorker = new MultiWorker({
        connection: api.resque.connectionDetails,
        queues: api.config.tasks.queues,
        timeout: api.config.tasks.timeout,
        checkTimeout: api.config.tasks.checkTimeout,
        minTaskProcessors: api.config.tasks.minTaskProcessors,
        maxTaskProcessors: api.config.tasks.maxTaskProcessors,
        maxEventLoopDelay: api.config.tasks.maxEventLoopDelay,
        toDisconnectProcessors: api.config.tasks.toDisconnectProcessors
      }, api.tasks.jobs)

      // normal worker emitters
      this.multiWorker.on('start', (workerId) =&gt; { api.log('worker: started', this.workerLogging.start, {workerId: workerId}) })
      this.multiWorker.on('end', (workerId) =&gt; { api.log('worker: ended', this.workerLogging.end, {workerId: workerId}) })
      this.multiWorker.on('cleaning_worker', (workerId, worker, pid) =&gt; { api.log(['worker: cleaning old worker %s, (%s)', worker
, pid], this.workerLogging.cleaning_worker) })
      this.multiWorker.on('poll', (workerId, queue) =&gt; { api.log(['worker: polling %s', queue], this.workerLogging.poll, {workerId
: workerId}) })
      this.multiWorker.on('job', (workerId, queue, job) =&gt; { api.log(['worker: working job %s', queue], this.workerLogging.job, {
workerId: workerId, job: {class: job['class'], queue: job.queue}}) })
      this.multiWorke ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.resque.start" id="apidoc.element.actionhero.resque.start">
        function <span class="apidocSignatureSpan">actionhero.resque.</span>start
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (api, next) {
  if (api.config.tasks.minTaskProcessors === 0 &amp;&amp; api.config.tasks.maxTaskProcessors &gt; 0) {
    api.config.tasks.minTaskProcessors = 1
  }

  api.resque.startQueue(function () {
    api.resque.startScheduler(function () {
      api.resque.startMultiWorker(function () {
        next()
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">start</span>(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.resque.stop" id="apidoc.element.actionhero.resque.stop">
        function <span class="apidocSignatureSpan">actionhero.resque.</span>stop
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (api, next) {
  api.resque.stopScheduler(function () {
    api.resque.stopMultiWorker(function () {
      api.resque.stopQueue(function () {
        next()
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.<span class="apidocCodeKeywordSpan">stop</span>(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
  this.api.projectRoot = process.env.project_root
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.servers" id="apidoc.module.actionhero.servers">module actionhero.servers</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.servers.initialize" id="apidoc.element.actionhero.servers.initialize">
        function <span class="apidocSignatureSpan">actionhero.servers.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.servers = {}
  api.servers.servers = {}

  // Load the servers

  let serverFolders = [
    path.resolve(path.join(__dirname, '/../servers'))
  ]

  api.config.general.paths.server.forEach((p) =&gt; {
    p = path.resolve(p)
    if (serverFolders.indexOf(p) &lt; 0) {
      serverFolders.push(p)
    }
  })

  let jobs = []

  serverFolders.forEach((p) =&gt; {
    api.utils.recursiveDirectoryGlob(p).forEach((f) =&gt; {
      let parts = f.split(/[/\\]+/)
      let serverName = parts[(parts.length - 1)].split('.')[0]
      if (api.config.servers[serverName] &amp;&amp; api.config.servers[serverName].enabled === true) {
        let init = require(f).initialize
        let options = api.config.servers[serverName]
        jobs.push((done) =&gt; {
          init(api, options, (serverObject) =&gt; {
            api.servers.servers[serverName] = serverObject
            api.log(['Initialized server: %s', serverName], 'debug')
            return done()
          })
        })
      }
      api.watchFileAndAct(f, () =&gt; {
        api.log(['*** Rebooting due to server (%s) change ***', serverName], 'info')
        api.commands.restart()
      })
    })
  })

  async.series(jobs, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.servers.start" id="apidoc.element.actionhero.servers.start">
        function <span class="apidocSignatureSpan">actionhero.servers.</span>start
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (api, next) {
  let jobs = []
  Object.keys(api.servers.servers).forEach((serverName) =&gt; {
    let server = api.servers.servers[serverName]
    if (server &amp;&amp; server.options.enabled === true) {
      let message = ''
      let messageArgs = []
      message += 'Starting server: `%s`'
      messageArgs.push(serverName)
      if (api.config.servers[serverName].bindIP) {
        message += ' @ %s'
        messageArgs.push(api.config.servers[serverName].bindIP)
      }
      if (api.config.servers[serverName].port) {
        message += ':%s'
        messageArgs.push(api.config.servers[serverName].port)
      }

      jobs.push((done) =&gt; {
        api.log([message].concat(messageArgs), 'notice')
        server.start((error) =&gt; {
          if (error) { return done(error) }
          api.log(['Server started: %s', serverName], 'debug')
          return done()
        })
      })
    }
  })

  async.series(jobs, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">start</span>(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.servers.stop" id="apidoc.element.actionhero.servers.stop">
        function <span class="apidocSignatureSpan">actionhero.servers.</span>stop
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (api, next) {
  let jobs = []
  Object.keys(api.servers.servers).forEach((serverName) =&gt; {
    let server = api.servers.servers[serverName]
    if ((server &amp;&amp; server.options.enabled === true) || !server) {
      jobs.push((done) =&gt; {
        api.log(['Stopping server: %s', serverName], 'notice')
        server.stop((error) =&gt; {
          if (error) { return done(error) }
          api.log(['Server stopped: %s', serverName], 'debug')
          return done()
        })
      })
    }
  })

  async.series(jobs, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.<span class="apidocCodeKeywordSpan">stop</span>(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
  this.api.projectRoot = process.env.project_root
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.socket" id="apidoc.module.actionhero.socket">module actionhero.socket</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.socket.initialize" id="apidoc.element.actionhero.socket.initialize">
        function <span class="apidocSignatureSpan">actionhero.socket.</span>initialize
        <span class="apidocSignatureSpan">(api, options, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, options, next) {
  // ////////
  // INIT //
  // ////////

  const type = 'socket'
  const attributes = {
    canChat: true,
    logConnections: true,
    logExits: true,
    pendingShutdownWaitLimit: 5000,
    sendWelcomeMessage: true,
    verbs: [
      'quit',
      'exit',
      'documentation',
      'paramAdd',
      'paramDelete',
      'paramView',
      'paramsView',
      'paramsDelete',
      'roomAdd',
      'roomLeave',
      'roomView',
      'detailsView',
      'say'
    ]
  }

  const server = new api.GenericServer(type, options, attributes)

  // ////////////////////
  // REQUIRED METHODS //
  // ////////////////////

  server.start = function (next) {
    if (options.secure === false) {
      server.server = net.createServer(api.config.servers.socket.serverOptions, (rawConnection) =&gt; {
        handleConnection(rawConnection)
      })
    } else {
      server.server = tls.createServer(api.config.servers.socket.serverOptions, (rawConnection) =&gt; {
        handleConnection(rawConnection)
      })
    }

    server.server.on('error', (e) =&gt; {
      return next(new Error('Cannot start socket server @ ' + options.bindIP + ':' + options.port + ' =&gt; ' + e.message))
    })

    server.server.listen(options.port, options.bindIP, () =&gt; {
      process.nextTick(next)
    })
  }

  server.stop = function (next) {
    gracefulShutdown(next)
  }

  server.sendMessage = function (connection, message, messageCount) {
    if (message.error) {
      message.error = api.config.errors.serializers.servers.socket(message.error)
    }

    if (connection.respondingTo) {
      message.messageCount = messageCount
      connection.respondingTo = null
    } else if (message.context === 'response') {
      if (messageCount) {
        message.messageCount = messageCount
      } else {
        message.messageCount = connection.messageCount
      }
    }
    try {
      connection.rawConnection.write(JSON.stringify(message) + '\r\n')
    } catch (e) {
      api.log(['socket write error: %s', e], 'error')
    }
  }

  server.goodbye = function (connection) {
    try {
      connection.rawConnection.end(JSON.stringify({status: connection.localize(api.config.servers.socket.goodbyeMessage), context
: 'api'}) + '\r\n')
    } catch (e) {}
  }

  server.sendFile = function (connection, error, fileStream) {
    if (error) {
      server.sendMessage(connection, error, connection.messageCount)
    } else {
      fileStream.pipe(connection.rawConnection, {end: false})
    }
  }

  // //////////
  // EVENTS //
  // //////////

  server.on('connection', function (connection) {
    connection.params = {}

    const parseLine = function (line) {
      if (api.config.servers.socket.maxDataLength &gt; 0) {
        let blen = Buffer.byteLength(line, 'utf8')
        if (blen &gt; api.config.servers.socket.maxDataLength) {
          let error = api.config.errors.dataLengthTooLarge(api.config.servers.socket.maxDataLength, blen)
          server.log(error, 'error')
          return server.sendMessage(connection, {status: 'error', error: error, context: 'response'})
        }
      }
      if (line.length &gt; 0) {
        // increment at the start of the request so that responses can be caught in order on the client
        // this is not handled by the GenericServer
        connection.messageCount++
        parseRequest(connection, line)
      }
    }

    connection.rawConnection.on('data', (chunk) =&gt; {
      if (checkBreakChars(chunk)) {
        connection.destroy()
      } else {
        // Replace all carriage returns with newlines.
        connection.rawConnection.socketDataString += chunk.toString('utf-8').replace(/\r/g, '\n')
        let index
        let d = String(api.config.servers.socket.delimiter)

        while ((index = connection.rawConnection.socketDataString.indexOf(d)) &gt; -1) {
          let data = connection.rawConnection.socketDataString.slice(0, index)
          connection.rawConnection.socketDataString = connection.rawConnection.socketDataString.slice(index + d.length)
          data.split(d).forEach(parseLine)
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.specHelper" id="apidoc.module.actionhero.specHelper">module actionhero.specHelper</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.specHelper.initialize" id="apidoc.element.actionhero.specHelper.initialize">
        function <span class="apidocSignatureSpan">actionhero.specHelper.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  if (api.env === 'test' || process.env.SPECHELPER === 'true' || process.env.SPECHELPER === true) {
    api.specHelper = {
      returnMetadata: true
    }

    // create a test 'server' to run actions
    api.specHelper.initialize = function (api, options, next) {
      const type = 'testServer'
      const attributes = {
        canChat: true,
        logConnections: false,
        logExits: false,
        sendWelcomeMessage: true,
        verbs: api.connections.allowedVerbs
      }

      const server = new api.GenericServer(type, options, attributes)

      server.start = function (next) {
        api.log('loading the testServer', 'warning')
        next()
      }

      server.stop = function (next) {
        next()
      }

      server.sendMessage = function (connection, message, messageCount) {
        process.nextTick(() =&gt; {
          connection.messages.push(message)
          if (typeof connection.actionCallbacks[messageCount] === 'function') {
            connection.actionCallbacks[messageCount](message, connection)
            delete connection.actionCallbacks[messageCount]
          }
        })
      }

      server.sendFile = function (connection, error, fileStream, mime, length) {
        let content = ''
        let response = {
          error: error,
          content: null,
          mime: mime,
          length: length
        }

        try {
          if (!error) {
            fileStream.on('data', (d) =&gt; { content += d })
            fileStream.on('end', () =&gt; {
              response.content = content
              server.sendMessage(connection, response, connection.messageCount)
            })
          } else {
            server.sendMessage(connection, response, connection.messageCount)
          }
        } catch (e) {
          api.log(e, 'warning')
          server.sendMessage(connection, response, connection.messageCount)
        }
      }

      server.goodbye = function () {
        //
      }

      server.on('connection', function (connection) {
        connection.messages = []
        connection.actionCallbacks = {}
      })

      server.on('actionComplete', function (data) {
        if (typeof data.response === 'string' || Array.isArray(data.response)) {
          if (data.response.error) {
            data.response = api.config.errors.serializers.servers.specHelper(data.response.error)
          }
        } else {
          if (data.response.error) {
            data.response.error = api.config.errors.serializers.servers.specHelper(data.response.error)
          }

          if (api.specHelper.returnMetadata) {
            data.response.messageCount = data.messageCount

            data.response.serverInformation = {
              serverName: api.config.general.serverName,
              apiVersion: api.config.general.apiVersion
            }

            data.response.requesterInformation = {
              id: data.connection.id,
              remoteIP: data.connection.remoteIP,
              receivedParams: {}
            }

            for (let k in data.params) {
              data.response.requesterInformation.receivedParams[k] = data.params[k]
            }
          }
        }

        if (data.toRender === true) {
          server.sendMessage(data.connection, data.response, data.messageCount)
        }
      })

      next(server)
    }

    api.specHelper.connection = function () {
      let id = uuid.v4()
      api.servers.servers.testServer.buildConnection({
        id: id,
        rawConnection: {},
        remoteAddress: 'testServer',
        remotePort: 0
      })

      return api.connections.connections[id]
    }

    api.specHelper.Connection = api.specHelper.connection

    // create helpers to run an action
    // data can be a params hash or a connection
    api.specHelper.runAction = function (actionName, input, next) {
      let connection
      if (typeof input === 'function' &amp;&amp; !next) {
        next = input
        input = {}
      }
      if (input.id &amp;&amp; input.type === 'testServer') {
        connection = input
      } else { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.actionhero.specHelper.start" id="apidoc.element.actionhero.specHelper.start">
        function <span class="apidocSignatureSpan">actionhero.specHelper.</span>start
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (api, next) {
  if (api.env === 'test' || process.env.SPECHELPER === 'true' || process.env.SPECHELPER === true) {
    api.specHelper.initialize(api, {}, (serverObject) =&gt; {
      api.servers.servers.testServer = serverObject
      api.servers.servers.testServer.start(() =&gt; {
        next()
      })
    })
  } else {
    next()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.initialize(params, callback) },
  start: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">start</span>(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()

if (process.env.project_root) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.staticFile" id="apidoc.module.actionhero.staticFile">module actionhero.staticFile</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.staticFile.initialize" id="apidoc.element.actionhero.staticFile.initialize">
        function <span class="apidocSignatureSpan">actionhero.staticFile.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  api.staticFile = {

    searchLoactions: [],

    searchPath: function (connection, counter) {
      if (!counter) { counter = 0 }
      if (api.staticFile.searchLoactions.length === 0 || counter &gt;= api.staticFile.searchLoactions.length) {
        return null
      } else {
        return api.staticFile.searchLoactions[counter]
      }
    },

    // connection.params.file should be set
    // callback is of the form: callback(connection, error, fileStream, mime, length)
    get: function (connection, callback, counter) {
      if (!counter) { counter = 0 }
      if (!connection.params.file || !api.staticFile.searchPath(connection, counter)) {
        this.sendFileNotFound(connection, api.config.errors.fileNotProvided(connection), callback)
      } else {
        let file
        if (!path.isAbsolute(connection.params.file)) {
          file = path.normalize(api.staticFile.searchPath(connection, counter) + '/' + connection.params.file)
        } else {
          file = connection.params.file
        }

        if (file.indexOf(path.normalize(api.staticFile.searchPath(connection, counter))) !== 0) {
          api.staticFile.get(connection, callback, counter + 1)
        } else {
          this.checkExistence(file, (error, exists, truePath) =&gt; {
            if (error) { throw error }
            if (exists) {
              this.sendFile(truePath, connection, callback)
            } else {
              api.staticFile.get(connection, callback, counter + 1)
            }
          })
        }
      }
    },

    sendFile: function (file, connection, callback) {
      let lastModified
      fs.stat(file, (error, stats) =&gt; {
        if (error) {
          this.sendFileNotFound(connection, api.config.errors.fileReadError(connection, String(error)), callback)
        } else {
          let mime = Mime.lookup(file)
          let length = stats.size
          let fileStream = fs.createReadStream(file)
          let start = new Date().getTime()
          lastModified = stats.mtime
          fileStream.on('end', () =&gt; {
            let duration = new Date().getTime() - start
            this.logRequest(file, connection, length, duration, true)
          })
          fileStream.on('error', (error) =&gt; {
            api.log(error)
          })
          fileStream.on('open', () =&gt; {
            callback(connection, null, fileStream, mime, length, lastModified)
          })
        }
      })
    },

    sendFileNotFound: function (connection, errorMessage, callback) {
      connection.error = new Error(errorMessage)
      this.logRequest('{not found}', connection, null, null, false)
      callback(connection, api.config.errors.fileNotFound(connection), null, 'text/html', api.config.errors.fileNotFound(connection
).length)
    },

    checkExistence: function (file, callback) {
      fs.stat(file, (error, stats) =&gt; {
        if (error) {
          callback(null, false, file)
        } else {
          if (stats.isDirectory()) {
            let indexPath = file + '/' + api.config.general.directoryFileType
            api.staticFile.checkExistence(indexPath, callback)
          } else if (stats.isSymbolicLink()) {
            fs.readLink(file, function (error, truePath) {
              if (error) {
                callback(null, false, file)
              } else {
                truePath = path.normalize(truePath)
                api.staticFile.checkExistence(truePath, callback)
              }
            })
          } else if (stats.isFile()) {
            callback(null, true, file)
          } else {
            callback(null, false, file)
          }
        }
      })
    },

    logRequest: function (file, connection, length, duration, success) {
      api.log(['[ file @ %s ]', connection.type], api.config.general.fileRequestLogLevel, {
        to: connection.remoteIP,
        file: file,
        requestedFile: connection.params.file,
        size: length,
        duration: duration,
        success: success
      })
    }

  }

  // load in the explicit public paths first
  if (api.config.general.paths ! ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.utils" id="apidoc.module.actionhero.utils">module actionhero.utils</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.utils.initialize" id="apidoc.element.actionhero.utils.initialize">
        function <span class="apidocSignatureSpan">actionhero.utils.</span>initialize
        <span class="apidocSignatureSpan">(api, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, next) {
  if (!api.utils) { api.utils = {} }

  // //////////////////////////////////////////////////////////////////////////
  // merge two hashes recursively
  api.utils.hashMerge = function (a, b, arg) {
    let c = {}
    let i
    let response

    for (i in a) {
      if (api.utils.isPlainObject(a[i]) &amp;&amp; Object.keys(a[i]).length &gt; 0) {
        c[i] = api.utils.hashMerge(c[i], a[i], arg)
      } else {
        if (typeof a[i] === 'function') {
          response = a[i](arg)
          if (api.utils.isPlainObject(response)) {
            c[i] = api.utils.hashMerge(c[i], response, arg)
          } else {
            c[i] = response
          }
        } else {
          c[i] = a[i]
        }
      }
    }
    for (i in b) {
      if (api.utils.isPlainObject(b[i]) &amp;&amp; Object.keys(b[i]).length &gt; 0) {
        c[i] = api.utils.hashMerge(c[i], b[i], arg)
      } else {
        if (typeof b[i] === 'function') {
          response = b[i](arg)
          if (api.utils.isPlainObject(response)) {
            c[i] = api.utils.hashMerge(c[i], response, arg)
          } else {
            c[i] = response
          }
        } else {
          c[i] = b[i]
        }
      }
    }
    return c
  }

  api.utils.isPlainObject = function (o) {
    const safeTypes = [Boolean, Number, String, Function, Array, Date, RegExp, Buffer]
    const safeInstances = ['boolean', 'number', 'string', 'function']
    const expandPreventMatchKey = '_toExpand' // set `_toExpand = false` within an object if you don't want to expand it
    let i

    if (!o) { return false }
    if ((o instanceof Object) === false) { return false }
    for (i in safeTypes) {
      if (o instanceof safeTypes[i]) { return false }
    }
    for (i in safeInstances) {
      if (typeof o === safeInstances[i]) { return false } //eslint-disable-line
    }
    if (o[expandPreventMatchKey] === false) { return false }
    return (o.toString() === '[object Object]')
  }

  // //////////////////////////////////////////////////////////////////////////
  // string to hash
  // http://stackoverflow.com/questions/6393943/convert-javascript-string-in-dot-notation-into-an-object-reference
  api.utils.stringToHash = function (path, object) {
    if (!object) { object = api }
    function _index (obj, i) { return obj[i] }
    return path.split('.').reduce(_index, object)
  }

  // //////////////////////////////////////////////////////////////////////////
  // unique-ify an array
  api.utils.arrayUniqueify = function (arr) {
    let a = []
    for (let i = 0; i &lt; arr.length; i++) {
      for (let j = i + 1; j &lt; arr.length; j++) {
        if (arr[i] === arr[j]) { j = ++i }
      }
      a.push(arr[i])
    }
    return a
  }

  // //////////////////////////////////////////////////////////////////////////
  // get all .js files in a directory
  api.utils.recursiveDirectoryGlob = function (dir, extension, followLinkFiles) {
    let results = []

    if (!extension) { extension = '.js' }
    if (!followLinkFiles) { followLinkFiles = true }

    extension = extension.replace('.', '')

    if (fs.existsSync(dir)) {
      fs.readdirSync(dir).forEach((file) =&gt; {
        let fullFilePath = path.join(dir, file)
        if (file[0] !== '.') { // ignore 'system' files
          let stats = fs.statSync(fullFilePath)
          let child
          if (stats.isDirectory()) {
            child = api.utils.recursiveDirectoryGlob(fullFilePath, extension, followLinkFiles)
            child.forEach((c) =&gt; { results.push(c) })
          } else if (stats.isSymbolicLink()) {
            let realPath = fs.readlinkSync(fullFilePath)
            child = api.utils.recursiveDirectoryGlob(realPath, extension, followLinkFiles)
            child.forEach((c) =&gt; { results.push(c) })
          } else if (stats.isFile()) {
            let fileParts = file.split('.')
            let ext = fileParts[(fileParts.length - 1)]
            // real file match
            if (ext === extension) { results.push(fullFilePath) }
            // linkfile traversal
            if (ext === 'link' &amp;&amp; followLinkFiles === true) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.web" id="apidoc.module.actionhero.web">module actionhero.web</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.web.initialize" id="apidoc.element.actionhero.web.initialize">
        function <span class="apidocSignatureSpan">actionhero.web.</span>initialize
        <span class="apidocSignatureSpan">(api, options, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, options, next) {
  // ////////
  // INIT //
  // ////////

  const type = 'web'
  const attributes = {
    canChat: false,
    logConnections: false,
    logExits: false,
    sendWelcomeMessage: false,
    verbs: [
      // no verbs for connections of this type, as they are to be very short-lived
    ]
  }

  const server = new api.GenericServer(type, options, attributes)

  if (['api', 'file'].indexOf(api.config.servers.web.rootEndpointType) &lt; 0) {
    throw new Error('api.config.servers.web.rootEndpointType can only be \'api\' or \'file\'')
  }

  // ////////////////////
  // REQUIRED METHODS //
  // ////////////////////

  server.start = function (next) {
    if (options.secure === false) {
      const http = require('http')
      server.server = http.createServer((req, res) =&gt; {
        handleRequest(req, res)
      })
    } else {
      const https = require('https')
      server.server = https.createServer(api.config.servers.web.serverOptions, (req, res) =&gt; {
        handleRequest(req, res)
      })
    }

    let bootAttempts = 0
    server.server.on('error', (e) =&gt; {
      bootAttempts++
      if (bootAttempts &lt; api.config.servers.web.bootAttempts) {
        server.log('cannot boot web server; trying again [' + String(e) + ']', 'error')
        if (bootAttempts === 1) { cleanSocket(options.bindIP, options.port) }
        setTimeout(() =&gt; {
          server.log('attempting to boot again..')
          server.server.listen(options.port, options.bindIP)
        }, 1000)
      } else {
        return next(new Error('cannot start web server @ ' + options.bindIP + ':' + options.port + ' =&gt; ' + e.message))
      }
    })

    server.server.listen(options.port, options.bindIP, () =&gt; {
      chmodSocket(options.bindIP, options.port)
      next()
    })
  }

  server.stop = function (next) {
    if (server.server) { server.server.close() }
    process.nextTick(next)
  }

  server.sendMessage = function (connection, message) {
    let stringResponse = ''
    if (connection.rawConnection.method !== 'HEAD') {
      stringResponse = String(message)
    }

    cleanHeaders(connection)
    const headers = connection.rawConnection.responseHeaders
    const responseHttpCode = parseInt(connection.rawConnection.responseHttpCode)

    server.sendWithCompression(connection, responseHttpCode, headers, stringResponse)
  }

  server.sendFile = function (connection, error, fileStream, mime, length, lastModified) {
    let foundCacheControl = false
    let ifModifiedSince
    let reqHeaders

    connection.rawConnection.responseHeaders.forEach((pair) =&gt; {
      if (pair[0].toLowerCase() === 'cache-control') { foundCacheControl = true }
    })

    connection.rawConnection.responseHeaders.push(['Content-Type', mime])

    if (fileStream) {
      if (!foundCacheControl) { connection.rawConnection.responseHeaders.push(['Cache-Control', 'max-age=' + api.config.servers.
web.flatFileCacheDuration + ', must-revalidate, public']) }
    }
    if (fileStream &amp;&amp; !api.config.servers.web.enableEtag) {
      if (lastModified) { connection.rawConnection.responseHeaders.push(['Last-Modified', new Date(lastModified).toUTCString()]) }
    }

    cleanHeaders(connection)
    const headers = connection.rawConnection.responseHeaders
    reqHeaders = connection.rawConnection.req.headers

    let sendRequestResult = function () {
      let responseHttpCode = parseInt(connection.rawConnection.responseHttpCode, 10)
      if (error) {
        server.sendWithCompression(connection, responseHttpCode, headers, String(error))
      } else if (responseHttpCode !== 304) {
        server.sendWithCompression(connection, responseHttpCode, headers, null, fileStream, length)
      } else {
        connection.rawConnection.res.writeHead(responseHttpCode, transformHeaders(headers))
        connection.rawConnection.res.end()
        connection.destroy()
      }
    }

    if (error) {
      connection.rawConnection.responseHttpCode = 404
      return sendRequestResult()
    }

    if (reqHeaders['if-modified-since']) {
      ifModifiedSince = new Date(reqHeaders['i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.actionhero.websocket" id="apidoc.module.actionhero.websocket">module actionhero.websocket</a></h1>


    <h2>
        <a href="#apidoc.element.actionhero.websocket.initialize" id="apidoc.element.actionhero.websocket.initialize">
        function <span class="apidocSignatureSpan">actionhero.websocket.</span>initialize
        <span class="apidocSignatureSpan">(api, options, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (api, options, next) {
  // ////////
  // INIT //
  // ////////

  const type = 'websocket'
  const attributes = {
    canChat: true,
    logConnections: true,
    logExits: true,
    sendWelcomeMessage: true,
    verbs: [
      'quit',
      'exit',
      'documentation',
      'roomAdd',
      'roomLeave',
      'roomView',
      'detailsView',
      'say'
    ]
  }

  const server = new api.GenericServer(type, options, attributes)

  // ////////////////////
  // REQUIRED METHODS //
  // ////////////////////

  server.start = function (next) {
    const webserver = api.servers.servers.web
    server.server = new Primus(webserver.server, api.config.servers.websocket.server)

    server.server.on('connection', (rawConnection) =&gt; {
      handleConnection(rawConnection)
    })

    server.server.on('disconnection', (rawConnection) =&gt; {
      handleDisconnection(rawConnection)
    })

    api.log(['webSockets bound to %s: %s', webserver.options.bindIP, webserver.options.port], 'debug')
    server.active = true

    server.writeClientJS()

    next()
  }

  server.stop = function (next) {
    server.active = false
    if (api.config.servers.websocket.destroyClientsOnShutdown === true) {
      server.connections().forEach((connection) =&gt; {
        connection.destroy()
      })
    }
    process.nextTick(next)
  }

  server.sendMessage = function (connection, message, messageCount) {
    if (message.error) {
      message.error = api.config.errors.serializers.servers.websocket(message.error)
    }

    if (!message.context) { message.context = 'response' }
    if (!messageCount) { messageCount = connection.messageCount }
    if (message.context === 'response' &amp;&amp; !message.messageCount) { message.messageCount = messageCount }
    connection.rawConnection.write(message)
  }

  server.sendFile = function (connection, error, fileStream, mime, length, lastModified) {
    let content = ''
    let response = {
      error: error,
      content: null,
      mime: mime,
      length: length,
      lastModified: lastModified
    }

    try {
      if (!error) {
        fileStream.on('data', function (d) { content += d })
        fileStream.on('end', () =&gt; {
          response.content = content
          server.sendMessage(connection, response, connection.messageCount)
        })
      } else {
        server.sendMessage(connection, response, connection.messageCount)
      }
    } catch (e) {
      api.log(e, 'warning')
      server.sendMessage(connection, response, connection.messageCount)
    }
  }

  server.goodbye = function (connection) {
    connection.rawConnection.end()
  }

  // //////////
  // EVENTS //
  // //////////

  server.on('connection', function (connection) {
    connection.rawConnection.on('data', (data) =&gt; {
      handleData(connection, data)
    })
  })

  server.on('actionComplete', function (data) {
    if (data.toRender !== false) {
      data.connection.response.messageCount = data.messageCount
      server.sendMessage(data.connection, data.response, data.messageCount)
    }
  })

  // //////////
  // CLIENT //
  // //////////

  server.compileActionheroClientJS = function () {
    let ahClientSource = fs.readFileSync(path.join(__dirname, '/../client/actionheroClient.js')).toString()
    let url = api.config.servers.websocket.clientUrl
    ahClientSource = ahClientSource.replace(/%%URL%%/g, url)
    let defaults = {}
    for (let i in api.config.servers.websocket.client) {
      defaults[i] = api.config.servers.websocket.client[i]
    }
    defaults.url = url
    let defaultsString = util.inspect(defaults)
    defaultsString = defaultsString.replace('\'window.location.origin\'', 'window.location.origin')
    ahClientSource = ahClientSource.replace('%%DEFAULTS%%', 'return ' + defaultsString)

    return ahClientSource
  }

  server.renderClientJS = function (minimize) {
    if (!minimize) { minimize = false }
    let libSource = api.servers.servers.websocket.server.library()
    let ahClientSource = server.compileActionheroClientJS()
    ahClientSource =
      ';;;\r\n' +
      '(function(exports){ \r\n' ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialized: false,
  shuttingDown: false
}
}

actionhero.prototype.initialize = function (params, callback) {
this.api.commands = {
  initialize: (params, callback) =&gt; { this.<span class="apidocCodeKeywordSpan">initialize</span>(params, callback) },
  start: (params, callback) =&gt; { this.start(params, callback) },
  stop: (callback) =&gt; { this.stop(callback) },
  restart: (callback) =&gt; { this.restart(callback) }
}

this.api.projectRoot = process.cwd()
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>